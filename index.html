<html>
<head>
  <title>Bikeshare map</title>
  <script src="https://d3js.org/d3.v4.min.js" charset="utf-8"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.18.0/d3-legend.js"></script>
<script src="d3.geo.tile.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://d3js.org/d3-ease.v1.min.js"></script>
<script src="https://d3js.org/d3-transition.v1.min.js"></script>
<script src="d3-tip.js"></script>



<link rel="stylesheet" href="mapzen_styles.css" /> 
<link rel="stylesheet" href="minimal-ui.css" /> 
</head>
<body>

  <header>
    <div class="container">
      <div class="txt-center">
        <h1 class="column12">Bikeshare Map</h1>
        <nav class="column12 nav nav-small">
            <a href="#usage">Usage</a>
            <a href="#nav">Navigation</a>
            <a href="#text">Text</a>
            <a href="#btnsAndTables">Buttons and Tables</a>
            <a href="#grid">Grid</a>
            <a href="#forms">Forms</a>
            <a href="#colors">Colors</a>
        </nav>
      </div>
    </div>

  </header>

<section class="bg-light" id="firstdescription">
    <div class="container">
      <div class="column6 prefix3">
        <h4>To start</h4>
          <div id="contents-md">
            Instructions go here.
          </div>
      </div>
    </div>
  </section>


<section class="container" id="topmap">
<div class="container">
    <div class="row">
    <div id="date">
      <p>Time of Day:</p>
      <p id="month"></p>
    </div>
    <div id="play"><button class="btn">Play</button></div>
    <div id="slider-container">
    </div>
    </div>
    <div id="mapBox" class="txt-center"><!-- Map container -->
    </div>

      <div id="selector">
      <div id="season">
      <h3>Season of 2016</h3>
        <select id="select-key-season">
          <option value="W">Winter</option>
          <option value="Sp">Spring</option>
          <option value="Su">Summer</option>
          <option value="F"  selected="selected">Fall</option>
        </select>
      </div>
      <div id="day">
      <h3>Day of Week</h3>
        <select id="select-key-day">
          <option value="WD" selected="selected">Weekday</option>
          <option value="WE">Weekend</option>
        </select>
      </div>
</div>

    <div id="stationinfo">
      <p>Selected Station:</p>
      <p id="stationname"></p>
    </div>
    <div id="plot" style="text-align:center;"><!-- Map container --> </div>
</div>
</section>
<section class="bg-light" id="seconddescription">
    <div class="container">
      <div class="column6 prefix3">
        <h4>Instructions</h4>
          <div id="contents-md">
            <ul>
            <li> Instructions go here.
            </ul>
          </div>
      </div>
    </div>
  </section>

<section class="container" id="matrix">
<div id="matrixBox" class="txt-center" style="text-align:center;"><!-- Box container -->
</div>

</section>
<script>

var yellow = d3.interpolateYlGn(0), // "rgb(255, 255, 229)"
    yellowGreen = d3.interpolateYlGn(0.5), // "rgb(120, 197, 120)"
    green = d3.interpolateYlGn(1); // "rgb(0, 69, 41)"

var width = Math.max(800, window.innerWidth/2),
    height = Math.max(600, window.innerHeight/1.25),
    plotboxheight = Math.max(400, window.innerHeight/1.5);

var margin = {top: 20, right: 40, bottom: 60, left: 60},
    plotwidth = width - margin.left - margin.right,
    plotheight = plotboxheight - margin.top - margin.bottom;

var timestep = 600;

var boxsize = 4;
    nValid = 0;

var sliderStart = 0;

var seasonKey = "F",
	dayKey = "WD",
	aggName = seasonKey + "_" + dayKey,
	timeIndex = 0,
	hoursPerSeason = 5*4*3;

var tiler = d3.geoTile()
    .size([width, height]);

var projection = d3.geoMercator()
    .center([-71.08, 42.354])
    .scale((1 << 21) / 2.7 / Math.PI)
    .translate([width / 2, height / 2]);

var areaScale = d3.scaleTime()
    .domain([0,20])
    .range([1, 32])
    .clamp(true);

var fillScale = d3.scaleSequential(d3.interpolateRdBu)
    .domain([-1,1]);

var cellScale = d3.scaleSequential(d3.interpolatePuOr)
    .domain([-1,1]);

var timeScale = d3.scaleTime()
    .domain([new Date(2000, 0, 1, 0), new Date(2000, 0, 2, 0)])
    .range([0,23])
    .clamp(true);

var formatTime = d3.timeFormat("%-I %p");

var path = d3.geoPath()
    .projection(projection);

var StationNames = [],
	StationOrder = [],
	ShowStation = [];

var sliderscale = d3.scaleLinear()
    .domain([7,width-207])
    .range([0,23])
    .interpolate(d3.interpolateRound)
    .clamp(true);

var dispatch = d3.dispatch("sliderChange");

var slider = d3.select("#slider-container")
    .style("width", width-200 + "px");
var sliderSVG = slider.append("svg")
    .attr("width", width-200 + "px")
    .attr("height",30 + "px");

var sliderbar = sliderSVG.append("rect")
    .attr("width", width-200 + "px")
    .attr("x", 0 + "px")
    .attr("y", 8 + "px")
    .attr("fill", "#9DD9D2")
    .attr("height",4 + "px");

sliderIcon = sliderSVG.append("circle")
    .attr("class", "slider-handle-icon")
    .attr("cx",sliderStart)
    .attr("cy",10)
    .attr("r",7)

var svg = d3.select("#mapBox").append("svg")
    .attr("width", width)
    .attr("height", height);

var tool_tip = d3.tip()
      .attr("class", "d3-tip")
      .offset([-8, 0])
      .html(function(d) { return d["Name"]; });
    svg.call(tool_tip);

var matrixsvg = d3.select("#matrixBox").append("svg")
	.attr("class", "matrixsvg")
    .attr("width", width)
    .attr("height", width);

var matrix_tool_tip = d3.tip()
      .attr("class", "d3-tip")
      .offset([-8, 0])
      .html(function(d) { return StationNames[d["O"]] + "<br>vs. <br> " + StationNames[d["D"]] });
    matrixsvg.call(matrix_tool_tip);

var plotsvg = d3.select("#plot").append("svg")
    .attr("width", width+ margin.left + margin.right)
    .attr("height", plotboxheight+ margin.top + margin.bottom)
    .attr("align","center");

var plotgroup = plotsvg.append("g")
    .attr("id","linechartgroup")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

var x = d3.scaleLinear()
  .range([margin.left,plotwidth-margin.right])
  .domain([new Date(2000, 0, 1, 0), new Date(2000, 0, 2, 1)]);
    
var y = d3.scaleLinear()
  .range([plotheight-margin.top,margin.bottom])
  .domain([0,1000]);

var xaxis = plotsvg.append("g")
  .call(d3.axisBottom(x)
  	.tickFormat(d3.timeFormat("%I:00 %p")))
  .attr("transform","translate(0," +plotheight + ")")
var yaxis = plotsvg.append("g")
  .call(d3.axisLeft(y))
  .attr("transform","translate(" +margin.left + ",0)")

var line = d3.line()
	.x(function(d,i) {
		return x(timeScale.invert(i));
	})
    .y(function(d) { 
    	return y(d/hoursPerSeason); })
    .curve(d3.curveCardinal);

var stationArea = d3.area()
	.x(function(d,i) {
		return x(timeScale.invert(i));
	})
	.y0(function(d) { 
    	return y(-d[1]/hoursPerSeason); })
    .y1(function(d) { 
    	return y(d[0]/hoursPerSeason); })
    .curve(d3.curveCardinal);

svg.selectAll("g")
    .data(tiler
      .scale(projection.scale() * 2 * Math.PI)
      .translate(projection([0, 0])))
  .enter().append("g")
    .each(function(d) {
      var g = d3.select(this);
      d3.queue().defer(d3.json,"https://vector.mapzen.com/osm/water/" + d[2] + "/" + d[0] + "/" + d[1] + ".json?api_key=mapzen-jovEguC")
      .defer(d3.json,"https://vector.mapzen.com/osm/roads/" + d[2] + "/" + d[0] + "/" + d[1] + ".json?api_key=mapzen-jovEguC")
      .await(function(error,file1,file2) {
        if (error) throw error;
          g.selectAll("path")
            .data(file1.features.sort(function(a, b) { return a.properties.sort_key - b.properties.sort_key; }))
            .enter().append("path")
            .attr("class", function(d) { var kind = d.properties.kind || ''; if(d.properties.boundary){kind += '_boundary';} return kind; })
           .attr("d", path);
          g.selectAll("path")
            .data(file2.features.sort(function(a, b) { return a.properties.sort_key - b.properties.sort_key; }))
            .enter().append("path")
            .attr("class", function(d) { 
              var kind = d.properties.kind || ''; if(d.properties.boundary){kind += '_boundary';} return kind; })
            .attr("d", path);
      });
    });
d3.queue().defer(d3.json,"Data/Formatted/stationData2.json")
		  .defer(d3.json,"Data/Formatted/odData.json")
		  .await(function(error, stationdata,oddata) {
  if (error) return console.warn(error);

  drawStations(stationdata);
  loopStations(0,stationdata);
  drawMatrix(oddata);
  console.log(stationdata[3])
  
  
  console.log(StationNames)
  console.log(StationOrder)

  function drawMatrix(oddata,stationdata) {
  	console.log(ShowStation)
  	// stationdata.each(function(d) {console.log(d)})
  	matrixsvg.selectAll("rect")
  		.data(oddata)
  		.enter()
  		.append("rect")
  		// .filter(function(d){
  		// 	return d[aggName] > 0
  		// })
  		.attr("class","cell")
  		.on('mouseover', matrix_tool_tip.show)
      	.on('mouseout', matrix_tool_tip.hide)
  		.attr("fill", function(d) { 
  			return cellScale(d[aggName]-1)})
  		.attr("transform", function(d){
  			return("translate("+ StationOrder[d["O"]-1]*boxsize+ "," + StationOrder[d["D"]-1]*boxsize +")")
  			})
  		.attr("width",boxsize)
  		.attr("height",boxsize);
  }

  function updateMatrix(oddata,stationdata) {
  	console.log(nValid)
  	var count = 0;
  	console.log("LOOK")
  	console.log(d3.select(".matrixsvg").attr("width"))
  	d3.select(".matrixsvg")
  		.attr("width",nValid*boxsize)
  		.attr("height",nValid*boxsize);
  	matrixsvg.selectAll("rect")
  		.attr("fill", function(d) { 
  			return cellScale(d[aggName]-1)})
  		.attr("transform", function(d){
  			return("translate("+ StationOrder[d["O"]-1]*boxsize+ "," + StationOrder[d["D"]-1]*boxsize +")")
  			})
  		.attr("width",boxsize)
  		.attr("height",boxsize);
  }

  function drawStations(stationdata) {
  	nValid = 0;
    svg.selectAll("circle")
      .data(stationdata)
      .enter().append("circle")
      .attr("class","station")
      .each(function(d,i) {
      	if (d[aggName].Dst_Show) {
      		nValid += 1;
      	}
      	StationNames = StationNames.concat(d["Name"]);
      	StationOrder = StationOrder.concat(d[aggName].Dst_Ord);
      	ShowStation = ShowStation.concat(d[aggName].Dst_Show);
      })
      .attr("fill", function(d) {
      	var starts = d[aggName].Starts[timeIndex];
      	var ends = d[aggName].Ends[timeIndex];
        return fillScale((starts - ends)/(starts + ends))
      })
      .attr("r", function(d) {
      	var starts = d[aggName].Starts[timeIndex];
      	var ends = d[aggName].Ends[timeIndex];
        return areaScale((starts + ends)/hoursPerSeason)
      })
      .style("opacity", function(d) {
      	return +d[aggName].Dst_Show})
      .on('click', function(d) {
      	d3.selectAll(".station")
      		.classed("selected",false)
      	d3.select(this).classed("selected",true).raise()
      	plotStation(d)
      }) 
      .on('mouseover', tool_tip.show)
      .on('mouseout', tool_tip.hide)
      .attr("transform", function(d) {
        var projectionTransform = projection([
          d.Lon,
          d.Lat
          ]) ;
        return "translate(" + projectionTransform+ ")"})
  }

  function updateStations(t,delayind,stationdata) {
  	nValid = 0;
    svg.selectAll(".station")
      .transition()
      .ease(d3.easeLinear)
      .duration(timestep)
      .delay(timestep*delayind)
      .attr("class","station")
      .each(function(d,i) {
      	if (d[aggName].Dst_Show) {
      		nValid += 1;
      	}
      	StationOrder[i] = d[aggName].Dst_Ord;
      	ShowStation[i] = d[aggName].Dst_Show;
      })
      .attr("fill", function(d) {
      	var starts = d[aggName].Starts[t];
      	var ends = d[aggName].Ends[t];
        return fillScale((starts - ends)/(starts + ends))
      })
      .attr("r", function(d) {
      	var starts = d[aggName].Starts[t];
      	var ends = d[aggName].Ends[t];
        return areaScale((starts + ends)/hoursPerSeason)
      })
      .style("opacity", function(d) {
      	return +d[aggName].Dst_Show})
  }

  function removeTransition(stationdata) {
    svg.selectAll(".station")
      .transition()
      .remove();
    d3.select(".slider-handle-icon")
      .transition()
      .remove();
  }

  function plotStation(elemData) { 
  	var arr = [elemData[aggName].Starts];
      	arr = d3.transpose(arr.concat([elemData[aggName].Ends]));
      	var border = d3.max(d3.max(arr));
      	console.log(d3.max(d3.max(arr)))
      	// y.domain([0, (d3.max(d3.merge([elemData[aggName].Starts,elemData[aggName].Ends])))/hoursPerSeason]);
      	y.domain([-border/hoursPerSeason,border/hoursPerSeason]);

      	yaxis.transition().call(d3.axisLeft(y))
      	d3.select("#stationinfo p#stationname")
      		.text( elemData.Name );
      	plotgroup.selectAll("path")
      		.remove();
      	plotgroup.append("path")
      		.datum(elemData)
      		.attr("id","StartLine")
      		.attr("class","line")
      		.attr("d", function(d) { 
      			// return line(elemData[aggName].Starts); 
      			return stationArea(arr); 
      		});
		// plotgroup.append("path")
  //     		.datum(elemData)
  //     		.attr("id","EndLine")
  //     		.attr("class","line")
  //     		.attr("d", function(d) { 
  //     			return line(elemData[aggName].Ends); 
  //     		});

      	}

  function loopStations(startTime, stationdata) {
  	d3.select('#play').classed("active",true)
    for (TimeIndex=startTime;TimeIndex<24;TimeIndex++) {
      updateStations(TimeIndex,(TimeIndex-startTime),stationdata);
      updateTimeBox(sliderscale.invert(TimeIndex),(TimeIndex-startTime))
      d3.select(".slider-handle-icon")
        .transition()
        .ease(d3.easeLinear)
        .duration(timestep)
        .delay(timestep*(TimeIndex-startTime))
        .attr("cx", sliderscale.invert(TimeIndex) + "px");
    }
    d3.select(".slider-handle-icon")
    	.transition()
    	.duration(0)
    	.delay(timestep*(TimeIndex-startTime))
    	.attr("cx", sliderscale.invert(0) + "px")
    	.on("end", function(d) {
    		TimeIndex = 0;
    		console.log(TimeIndex)
    		updateStationsSlider(TimeIndex,stationdata)
    		d3.select('#play').classed("active",false)
    		console.log(d3.select('#play').classed("active"))
    	});
  }


  slider.call(d3.drag()
    .on("start", function(){
    	console.log(d3.mouse(this)[2])
      dispatch.call("sliderChange", {about: "I am a context object"}, d3.mouse(this)[0])})
    .on("drag", function(){
      dispatch.call("sliderChange", {about: "I am a context object"}, d3.mouse(this)[0])})
    .on("end", function(){
      dispatch.call("sliderChange", {about: "I am a context object"}, d3.mouse(this)[0])})
    );

  dispatch.on("sliderChange", function(value) {
    // var newvalue = value;
    if (value  < 0) {newvalue = 0}
      else if (value  > width) {newvalue = width}
      else {newvalue = value}
    d3.select(".slider-handle-icon")
        .transition();
    updateTimeBox(newvalue,0)
    sliderIcon.attr("cx", newvalue + "px");
    TimeIndex = sliderscale(newvalue);
    updateStationsSlider(TimeIndex,stationdata)
  });

  function updateTimeBox(xPosition,delay) {
    var monthLabel = formatTime(timeScale.invert(sliderscale(xPosition)));
    d3.select("#date p#month")
      .transition()
      .delay(delay*timestep)
      .text( monthLabel );
  }

  function updateLines(aggName,hoursPerSeason) {
     plotgroup.select("#StartLine")
     		.transition()
      		.attr("d", function(d) { 
      			y.domain([0, (d3.max(d3.merge([d[aggName].Starts,d[aggName].Ends])))/hoursPerSeason]);
    			yaxis.transition().call(d3.axisLeft(y))
      			return line(d[aggName].Starts); 
      		});
	plotgroup.select("#EndLine")
			.transition()
			.duration(600)
			.attr("d", function(d) {
				return line(y(d[aggName].Ends))
			}
				)
      		// .attr("d", function(d) { 
      			// return line(d[aggName].Ends); 
      		// })
;
  }

function pauseTransition(stationdata) {
	d3.select(".slider-handle-icon")
		.transition()
		.duration(0);
    var xPosition = parseFloat(d3.select(".slider-handle-icon").attr("cx"));
	updateTimeBox(xPosition,0)
	TimeIndex = sliderscale(xPosition)
	updateStations(TimeIndex,0,stationdata)
	d3.select('#play').classed("active",false)
}

  function updateStationsSlider(sliderValue,stationdata) {
    updateStations(sliderValue,0,stationdata);
  };

d3.select('#select-key-season').on('change', function(a) {
  seasonKey = d3.select(this).property('value');
  aggName = seasonKey + "_" + dayKey,
  // removeTransition(stationdata) 
  pauseTransition(stationdata)
  updateLines(aggName,hoursPerSeason);
  updateStations(TimeIndex,0,stationdata);
  updateMatrix(oddata,stationdata);
});

d3.select('#select-key-day').on('change', function(a) {
  dayKey = d3.select(this).property('value');
  aggName = seasonKey + "_" + dayKey,
  console.log(aggName)
  if (dayKey == "WE") 
  	{hoursPerSeason = 2*4*3;}
  	else
  	{hoursPerSeason = 5*4*3;}
  // removeTransition(stationdata) 
  pauseTransition(stationdata)
  updateLines(aggName,hoursPerSeason);
  updateStations(TimeIndex,0,stationdata);
  updateMatrix(oddata,stationdata);
});

d3.select('#play').on('click', function(a) {
	if (d3.select(this).classed("active"))
		{
			pauseTransition(stationdata)
		}
	else {
		console.log(TimeIndex)
		loopStations(TimeIndex,stationdata)
		// d3.select(this).classed("btn-active",true)
		}
		console.log(d3.select(this).classed("active"))
});

});



</script>
</body>
</html>