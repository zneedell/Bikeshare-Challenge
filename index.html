<html>
<head>
  <title>Bikeshare map</title>
  <script src="https://d3js.org/d3.v4.min.js" charset="utf-8"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.18.0/d3-legend.js"></script>
<script src="d3.geo.tile.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://d3js.org/d3-ease.v1.min.js"></script>
<script src="https://d3js.org/d3-transition.v1.min.js"></script>



<link rel="stylesheet" href="mapzen_styles.css" /> 
<link rel="stylesheet" href="minimal-ui.css" /> 
</head>
<body>

  <header>
    <div class="container">
      <div class="txt-center">
        <h1 class="column12">Bikeshare Map</h1>
      </div>
    </div>
  </header>

<div class="container">
      <div id="selector">
      <div id="season">
      <h3>Season of 2016</h3>
        <select id="select-key-season">
          <option value="Winter">Winter</option>
          <option value="Spring">Spring</option>
          <option value="Summer">Summer</option>
          <option value="Fall"  selected="selected">Fall</option>
        </select>
      </div>
      <div id="day">
      <h3>Day of Week</h3>
        <select id="select-key-day">
          <option value="Weekday" selected="selected">Weekday</option>
          <option value="Weekend">Weekend</option>
        </select>
      </div>
</div>
<div class="container">
    <div class="row">
    <div id="date">
      <p>Time of Day:</p>
      <p id="month"></p>
    </div>
    <div id="play"><button class="btn">Play</button></div>
    <div id="slider-container">
<!--       <div id="slider-div"></div>
      <div id="slider-probe">
        <p></p>
        <div></div>
      </div> -->
    </div>
    </div>
    <div id="mapBox" class="txt-center"><!-- Map container -->
    </div>
    <div id="stationinfo">
      <p>Selected Station:</p>
      <p id="stationname"></p>
    </div>
    <div id="plot"><!-- Map container --> </div>
</div>

  <script>


var width = Math.max(960, window.innerWidth/2),
    height = Math.max(500, window.innerHeight/1.25),
    plotboxheight = Math.max(400, window.innerHeight/1.5);

var margin = {top: 20, right: 40, bottom: 60, left: 60},
    plotwidth = width - margin.left - margin.right,
    plotheight = plotboxheight - margin.top - margin.bottom;

var timestep = 300;

var sliderStart = 240;

var seasonKey = "Fall"
	startName = seasonKey + "Starts",
	endName = seasonKey + "Ends",
	timeIndex = 0;

var tiler = d3.geoTile()
    .size([width, height]);

var projection = d3.geoMercator()
    .center([-71.09, 42.363])
    .scale((1 << 21) / 2.4 / Math.PI)
    .translate([width / 2, height / 2]);

var areaScale = d3.scaleTime()
    .domain([0,877])
    .range([0, 40]);

var fillScale = d3.scaleSequential(d3.interpolateRdBu)
    .domain([-1,1]);

var timeScale = d3.scaleTime()
    .domain([new Date(2000, 0, 1, 0), new Date(2000, 0, 2, 0)])
    .range([0,47])
    .clamp(true);

// var reverseTimeScale = d3.scaleTime()
//     .range([new Date(2000, 0, 1, 0), new Date(2000, 0, 2, 0)])
//     .time([0,47])
//     .ticks(48);

var formatTime = d3.timeFormat("%-I %p");

var path = d3.geoPath()
    .projection(projection);


var sliderscale = d3.scaleLinear()
    .domain([sliderStart,width])
    .range([0,47])
    .interpolate(d3.interpolateRound)
    .clamp(true);

var dispatch = d3.dispatch("sliderChange");

var slider = d3.select("#slider-container")
    .style("width", width-200 + "px");
var sliderSVG = slider.append("svg")
    .attr("width", width-200 + "px")
    .attr("height",30 + "px");

var sliderbar = sliderSVG.append("rect")
    .attr("width", width-200 + "px")
    .attr("x", 0 + "px")
    .attr("y", 8 + "px")
    .attr("fill", "#9DD9D2")
    .attr("height",4 + "px");

// var sliderTray = sliderSVG.append("div")
//     .attr("class", "slider-tray");

// var sliderHandle = sliderTray.append("g")
//     .attr("class", "slider-handle");

sliderIcon = sliderSVG.append("circle")
    .attr("class", "slider-handle-icon")
    .attr("cx",sliderStart)
    .attr("cy",10)
    .attr("r",7)

// sliderHandle.append("circle")
//     .attr("class", "slider-handle-icon")


var svg = d3.select("#mapBox").append("svg")
    .attr("width", width)
    .attr("height", height);

var plotsvg = d3.select("#plot").append("svg")
    .attr("width", width+ margin.left + margin.right)
    .attr("height", plotboxheight+ margin.top + margin.bottom);

var plotgroup = plotsvg.append("g")
    .attr("id","linechartgroup")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

var x = d3.scaleLinear()
  .range([margin.left,plotwidth])
  .domain([new Date(2000, 0, 1, 0), new Date(2000, 0, 2, 1)]);
    
var y = d3.scaleLinear()
  .range([plotheight,margin.bottom])
  .domain([0,1000]);

var xaxis = plotsvg.append("g")
  .call(d3.axisBottom(x)
  	.tickFormat(d3.timeFormat("%I:00 %p")))
  .attr("transform","translate(0," +plotheight + ")")
var yaxis = plotsvg.append("g")
  .call(d3.axisLeft(y))
  .attr("transform","translate(" +margin.left + ",0)")

var line = d3.line()
	.x(function(d,i) {
		// plotgroup.append("circle")
		// 	.attr("cx", x(timeScale.invert(i)))
		// 	.attr("cy", y(d))
		// 	.attr("r", 3)
		// 	.attr("fill", fillScale(-0.8))
		return x(timeScale.invert(i));
	})
    .y(function(d) { 
    	console.log((d))
    	return y(d); });

svg.selectAll("g")
    .data(tiler
      .scale(projection.scale() * 2 * Math.PI)
      .translate(projection([0, 0])))
  .enter().append("g")
    .each(function(d) {
      var g = d3.select(this);
      d3.queue().defer(d3.json,"https://vector.mapzen.com/osm/water/" + d[2] + "/" + d[0] + "/" + d[1] + ".json?api_key=vector-tiles-LM25tq4")
      .defer(d3.json,"https://vector.mapzen.com/osm/roads/" + d[2] + "/" + d[0] + "/" + d[1] + ".json?api_key=vector-tiles-LM25tq4")
      .await(function(error,file1,file2) {
        if (error) throw error;
          g.selectAll("path")
            .data(file1.features.sort(function(a, b) { return a.properties.sort_key - b.properties.sort_key; }))
            .enter().append("path")
            .attr("class", function(d) { var kind = d.properties.kind || ''; if(d.properties.boundary){kind += '_boundary';} return kind; })
           .attr("d", path);
          g.selectAll("path")
            .data(file2.features.sort(function(a, b) { return a.properties.sort_key - b.properties.sort_key; }))
            .enter().append("path")
            .attr("class", function(d) { 
              var kind = d.properties.kind || ''; if(d.properties.boundary){kind += '_boundary';} return kind; })
            .attr("d", path);
      });
    });

d3.json("Data/Formatted/stationData.json",function(error, stationdata) {
  if (error) return console.warn(error);

  function drawStations(stationdata) {
    svg.selectAll("circle")
      .data(stationdata)
      .enter().append("circle")
      .attr("class","station")
      .attr("fill", function(d) {
      	var starts = d[startName][timeIndex];
      	var ends = d[endName][timeIndex];
        return fillScale((starts - ends)/(starts + ends))
      })
      .attr("r", function(d) {
      	var starts = d[startName][timeIndex];
      	var ends = d[endName][timeIndex];
        return areaScale((starts + ends))
      })
      .on('click', function(a) { 
      	y.domain([0, d3.max(d3.merge([a[startName],a[endName]]))]);
      	yaxis.transition().call(d3.axisLeft(y))
      	d3.select("#stationinfo p#stationname")
      		.text( a.Name );
      	plotgroup.selectAll("path")
      		.remove();
      	plotgroup.selectAll("circle")
      		.remove();
      	plotgroup.append("path")
      		.datum(a)
      		.attr("id","StartLine")
      		.attr("class","line")
      		.attr("d", function(d) { 
      			return line(a[startName]); 
      		});
		plotgroup.append("path")
      		.datum(a)
      		.attr("id","EndLine")
      		.attr("class","line")
      		.attr("d", function(d) { 
      			return line(a[endName]); 
      		});

      	})
      .attr("transform", function(d) {
        var projectionTransform = projection([
          d.Lon,
          d.Lat
          ]) ;
        return "translate(" + projectionTransform+ ")"})
    	.append("title")
    	.text(function(d) {
    		return "(" + 
      		d["Name"]
    		 + ")"
   		})
  }

  function updateStations(timeind,delayind,stationdata) {
    var keys = d3.keys(stationdata[0]);
    svg.selectAll(".station")
      .transition()
      .ease(d3.easeLinear)
      .duration(timestep)
      .delay(timestep*delayind)
      .attr("class","station")
      .attr("fill", function(d) {
      	var starts = d[startName][timeind];
      	var ends = d[endName][timeind];
        return fillScale((starts - ends)/(starts + ends))
      })
      .attr("r", function(d) {
      	var starts = d[startName][timeind];
      	var ends = d[endName][timeind];
        return areaScale((starts + ends))
      })
  }


  drawStations(stationdata) 
  loopStations(stationdata)

  function loopStations(stationdata) {
    for (ii=0;ii<48;ii++) {
      updateStations(ii,ii,stationdata);
      updateTimeBox(sliderscale.invert(ii),ii)
      d3.select(".slider-handle-icon")
        .transition()
        .duration(timestep)
        .delay(timestep*ii)
        .attr("cx", sliderscale.invert(ii)-sliderStart + "px");
    }
    // updateStations(0,48,stationdata);
    // updateTimeBox(sliderscale.invert(0),ii)
  }


  slider.call(d3.drag()
    .on("start", function(){
      dispatch.call("sliderChange", {about: "I am a context object"}, d3.event.x)})
    .on("drag", function(){
      dispatch.call("sliderChange", {about: "I am a context object"}, d3.event.x)})
    .on("end", function(){
      dispatch.call("sliderChange", {about: "I am a context object"}, d3.event.x)})
    );

  dispatch.on("sliderChange", function(value) {
    // var newvalue = value;
    if (value - sliderStart < 0) {newvalue = sliderStart}
      else if (value - sliderStart > width) {newvalue = width+sliderStart}
      else {newvalue = value}
    d3.select(".slider-handle-icon")
        .transition();
    updateTimeBox(newvalue,0)
    sliderIcon.attr("cx", newvalue-sliderStart + "px");
    newTime = sliderscale(newvalue);
    updateStationsSlider(newTime,stationdata)
  });

  function updateTimeBox(xPosition,delay) {
    var monthLabel = formatTime(timeScale.invert(sliderscale(xPosition)));
    d3.select("#date p#month")
      .transition()
      .delay(delay*timestep)
      .text( monthLabel );
  }

  function updateStationsSlider(sliderValue,stationdata) {
    updateStations(sliderValue,0,stationdata);
  };

d3.select('#select-key-season').on('change', function(a) {
  // Change the current key and call the function to update the colors.
  seasonKey = d3.select(this).property('value');
  startName = seasonKey + "Starts";
  endName = seasonKey + "Ends";
  console.log(startName)
  updateStations(newTime,0,stationdata);
});

d3.select('#play').on('click', function(a) {
  // Change the current key and call the function to update the colors.
    loopStations(stationdata);
});

});



</script>
</body>
</html>